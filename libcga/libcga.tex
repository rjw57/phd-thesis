\begin{savequote}[0.5\paperwidth]
\quoteperson{As soon as we started programming, we found to our surprise that it wasn't as easy to get programs right as we had thought. Debugging had to be discovered. I can remember the exact instant when I realised that a large part of my life from then on was going to be spent in finding mistakes in my own programs.}%
{Maurice Wilkes}
\end{savequote}

\chapter{LibCGA --- A Library for Implementing GA-based Algorithms}

Any GA-based algorithm must have a method of implementation to be
truly useful in any Engineering sense. In order to provide a solid
base for the development of such algorithms it was decided that
a good general-purpose GA library should be created in order to 
allow for rapid prototyping of GA-based solutions. The library 
was called \libcga{}.

\section{Requirements}

There were a number of design aims when designing the \libcga\ software library.

\begin{itemize}
\item Fast --- The library should be numerically efficient.
\item User-friendly --- The library Application Programmer's Interface (API) should be convenient and simple to use.
\item Compact --- The library should be small enough to be embedded within
a larger solution.
\item Thin --- The library should be sufficiently low-level so as to introduce
little penalty for wrapping it in a higher-level API.
\end{itemize}

These design aims were, by their nature, highly coupled. Research into
CGA would influence the design of the library and design of the library would
promote and influence the direction of the research. Because of this
I decided to make use of the spiral model of software development where
the software is incrementally improved from an initial prototype to adapt
to changing design parameters and new features.

It was decided that the implementation should follow the 
Object-Oriented Programming (OOP) methodology due to the natural mapping
between multivectors and operators in GA and objects and object-operators
in OOP. The C language was chosen because of the availability of high-quality 
optimising compilers and the relative closeness of the language to machine 
code, minimising the amount of intermediary code output from the compiler.

One way in the C language of writing object-orientated programs is to make
use of \emph{opaque data structures}. An internal structure type is defined
and all library API functions communicate
with the library passing a 
pointer to the structure as the first argument. All access to the
structure is done by the library through this pointer so the library
user need not know of the structure's layout. This is an example
of \emph{data hiding}, a common feature of object-orientated programming.

\section{Overview}


Any multivector $M$ in $\mathcal{A}(p,q)$ can be formed from a linear
combination of all possible basis vector products up to grade $p+q$. For
$\mathcal{A}(4,1)$, the highest grade object is $e_1e_2e_3e\bar{e}$ so \[ M =
a_1 + a_2 e_1 + a_3 e_2 + ... + a_7 e_1e_2 + ... + a_{32} e_1e_2e_3e\bar{e} \]

Initially \libcga\ stored a multivector as the vector $[ a_1, a_2, ...
a_{32} ]'$ implemented as an array. Later optimisations added the ability to
keep track of which grades were present in the multivector and this will be
addressed later.

\begin{figure}
\centering
\input{gaigen_matrix.tex}
\caption{Example product matrix for the geometric product in
$\mathcal{A}(3,0)$. $A_{ij...k}$ is the element of $A$ proportional to
$e_ie_j...e_k$.\label{fig:gaigen_matrix}}
\end{figure}

The various multivector products may be found by expanding out the terms of the
product and simplifying using a product table similar to Table
\ref{tab:gaigen_output}.  Alternatively, one may view the multivectors $A, B,
C$ as the vector representations $\mathbf{A}, \mathbf{B}, \mathbf{C}$ and
calculate $C = AB$ using \[ \mathbf{C} = A^{G} \mathbf{B} \] where $A^G$ is a
$32 \times 32$ matrix whose elements depend on the operator used (in this case
the geometric product) and the elements of $\mathbf{A}$. A little thought makes
it clear that all linear operators can be expressed in this form and so all the
operators we have defined can thus be expressed. An example matrix for the
geometric product in $\mathcal{A}(3,0)$ generated by Gaigen is shown in figure
\ref{fig:gaigen_matrix}.

This method is somewhat sub-optimal since $n \times n$ matrix-vector
multiplications require $O(n^2)$ operations. Techniques were developed to
reduce this general form to a set of more compact, efficient operations and
these will be outlined in section \ref{sec:grade_tracking}.


\section{Implementation Details}

\subsection{Coding style}

In common with many modern APIs it was decided the library should posess
an object-oriented API. One
way in the C language of writing object-orientated programs is to make
use of \emph{opaque data structures}. An internal structure type is defined
and all library API functions communicate with the library passing a 
pointer to the structure as the first argument. All access to the
structure is done by the library through this pointer so the library
user need not know of the structure's layout. This is an example
of \emph{data hiding}, a common feature of object-orientated programming.

\begin{figure}
\centering
\begin{minipage}{8cm}
\lstinputlisting[language=c]{struct_example.c}
\end{minipage}
\caption{Object-orientation in C.\label{fig:oopc}}
\end{figure}

An example of how to create constructor, destructor and member access 
functions in C is given in Figure \ref{fig:oopc}. From the programmers'
point of view they only have to use the API function passing the handle returned
by \textsf{widget\_new()} as the first argument.

\subsection{Product Table Generation}

Product tables were generated with a Perl
%\footnote{Practical Extraction and Report
%Language---see http://www.perl.com/} 
script in which $n$-vector components were represented
by a string of digits. For example, the trivector $e_1e_4e_5$ was represented as
`{\tt 145}'. Similarly $e_1e_5e_4$ was reordered and
represented as `{\tt -145}' so that the 
possible representations conformed to a set of basis elements.

A ny geometric produc between two blades was then calculated using the algorithm
represented in figure \ref{fig:symbolic}. The algorithm 
can be outlined as followed:

\begin{enumerate}
\item Sort first component numerically by exchanging neighbours and alternate sign
once for each swap.
\item Reverse sort second component numerically by exchanging neighbours and alternate sign
once for each swap.
\item If the last digit of the first component and first digit of the second
component match, change sign as appropriate to the square of the components and
remove.
\item If there are more pairs to match, goto step 3.
\item Concatenate components and output.
\end{enumerate}

\begin{figure}
\centering
\scalebox{0.75}{\includegraphics{symbolic}}
\caption{Example of finding that $e_{145}e_{452} = e_{12}$ with $e_5^2 = -1$, $e_4^2 = 1$.
\label{fig:symbolic}}
\end{figure}

Other product tables were computed from the geometric product. For example 
$a \cdot b = 0.5 (ab + ba)$.

These product tables were then used to generate optimal $n$-vector, $m$-vector product 
routines in C which operated directly on the multivector components.


\subsection{Grade Tracking}
\label{sec:grade_tracking}

\begin{table}
\centering
\begin{tabular}{cc|cccccc}
 \multicolumn{2}{c}{} & \multicolumn{6}{c}{$s$} \\
&  & 0 & 1 & 2 & 3 & 4 & 5 \\
\cline{2-8}
& 0 & 1 & 5 &10 &10 & 5 & 1 \\
& 1 & 5 & 25&50 &50 &25 & 5\\
& 2 & 10& 50&100&100&50 & 10\\
\raisebox{1.5ex}[0pt]{$r$} & 3 & 10& 50&100&100&50 & 10\\
& 4 & 5 & 25&50 &50 &25 & 5\\
& 5 & 1 & 5 &10 &10 & 5 & 1
\end{tabular}
\caption{Multiplication count for finding the geometric product of an
$r$-vector and $s$-vector.
\label{tab:grades}}
\end{table}

Table \ref{tab:grades} shows the number of floating-point multiplications to
compute the geometric product of a pure $r$-vector and pure $s$-vector. As you can
see even for a worst case bivector-bivector product only 100 multiplications
are required compared to 1024 for the general product. This suggests that
significant speedups can be obtained if only those grades present in the
multivector are considered.

The script used to generate the product tables above could also be used to
generate specific $n$-vector, $m$-vector product tables. These specific
tables often used far fewer flops than required for the general operator.
This effectively exploited the sparseness of the product matrix for single-grade
products.

When looking for an optimisation strategy the following properties are desirable:

\begin{itemize}
\item Transparent to the programmer --- the core \libcga\ API.
\item Straightforward to implement.
\item Generic (i.e.\ not limited to $\mathcal{A}(4,1)$.
\item Provide significant reduction in floating point operation count.
\end{itemize}

It was clear that optimised product implementations provided significant speedups but
required the programmer to know in advance which grades were present in a 
multivector (not always possible if the multivector is ultimately due to
user input). The solution was to represent the general multivector $M$
as a sum of single-grade objects
\[
M = \left<M\right>_0 + \left<M\right>_1 + ... + \left<M\right>_n
\]
where $\left<M\right>_i$ represents taking the grade $i$ component of $M$ and thus
the product of the multivectors $A$ and $B$ is
\begin{eqnarray*}
\lefteqn{AB = \left<A\right>_0\left<B\right>_0 + \left<A\right>_0\left<B\right>_1 + ...} \\
   && + \left<A\right>_1\left<B\right>_0 + \left<A\right>_1\left<B\right>_1 + ...  \\
   && + \left<A\right>_n\left<B\right>_{n-1} + \left<A\right>_n\left<B\right>_n
\end{eqnarray*}

Now let $G_A$ be the set of grades present in $A$ and $G_B$ be the set of grades present
in $B$ so that
\begin{eqnarray*}
\left<A\right>_i & = & 0 \quad \mbox{ if } i \notin G_A \\
\left<B\right>_i & = & 0 \quad \mbox{ if } i \notin G_B
\end{eqnarray*}
hence it can be said that
\[
\left<A\right>_i\left<B\right>_j = 0 \quad \mbox{ if } i \notin G_A \mbox{ or } j \notin G_B
\]
and need not be computed. If $G_A$ and $G_B$ are sufficiently small with respect to
$\{0 ... 5\}$ then significant advantage may be obtained.

In order to implement this it was necessary to record in the multivector which
grades were present. The most time and space efficient method to do this in
C is via a bit-mask. This technique keeps a 32-bit unsigned integer called the
\emph{grade mask}. If bit $n$ in the mask is set then grade $n$ is present. 
This does limit the maximum grade to 32-bits but this can be extended to 64-grade
by using a 64-bit integer on certain systems (e.g.\ the IA-64 next generation
Intel processor) or even higher order grades by utilising multi-word masks.

The advantage of using the object-orientated programming methodology now
became clear, in that a grade mask field could be added to the opaque
\texttt{multiv\_t} data type without changing the API. Also, since the 
program using \libcga\ only referenced this structure through a pointer,
existing programs were \emph{binary compatible}, that is they didn't have to be
recompiled.

The product function itself was modified to check for the presence of each 
grade-pair in the two input multivectors and only call the appropriate 
set of single-grade routines. It was the job of each single-grade
product function to set the appropriate grade mask bits in the output multivector.
This approach is shown diagrammatically in figure \ref{fig:parallel}

\begin{figure}
\centering
\scalebox{0.55}{
\includegraphics{parallel}
}
\caption{The method of grade tracking represented graphically. The shaded
numbers represent the grades present in each multivector.\label{fig:parallel}}
\end{figure}

% 
% \subsection{Algebra Plugins}
% 
% TBC
% 
% \section{Layering}
% 
% \subsection{Porting to Different Environments}
% 
% \subsubsection{Python}
% \subsubsection{Mono (.NET)}
% 
% \subsection{Embedding}
% 
